import{z as ye,i as be,t as d,p as Pe,a as we,g as ve,b as Ee,c as Ie,e as G,d as u,f as v,B as k,s as he,h as J,j as de,k as U,l as Y,m as R,w as xe,n as pe,u as Le,o as Z,q,r as Se,v as P,M as B,x as ie,y as Q,S as Ae,A as h,R as A,C as K,D as Fe,E as ne,T as oe}from"./index-DzZ0PsJo.js";import{Chain as ze,Common as H}from"./index-Cwxd9Ag7.js";class E{constructor(e){if(e.length!==20)throw new Error("Invalid address length");this.bytes=e}static zero(){return new E(ye(20))}static fromString(e){if(!be(e))throw new Error("Invalid address");return new E(d(e))}static fromPublicKey(e){if(!(e instanceof Uint8Array))throw new Error("Public key should be Uint8Array");const t=Pe(e);return new E(t)}static fromPrivateKey(e){if(!(e instanceof Uint8Array))throw new Error("Private key should be Uint8Array");const t=we(e);return new E(t)}static generate(e,t){if(typeof t!="bigint")throw new Error("Expected nonce to be a bigint");return new E(ve(e.bytes,Ee(t)))}static generate2(e,t,r){if(!(t instanceof Uint8Array))throw new Error("Expected salt to be a Uint8Array");if(!(r instanceof Uint8Array))throw new Error("Expected initCode to be a Uint8Array");return new E(Ie(e.bytes,t,r))}equals(e){return G(this.bytes,e.bytes)}isZero(){return this.equals(E.zero())}isPrecompileOrSystemAddress(){const e=u(this.bytes),t=k,r=BigInt("0xffff");return e>=t&&e<=r}toString(){return v(this.bytes)}toBytes(){return new Uint8Array(this.bytes)}}function Ce(s,e,t){const r=he.sign(s,e),i=r.toCompactRawBytes(),n=i.slice(0,32),o=i.slice(32,64),a=t===void 0?BigInt(r.recovery+27):BigInt(r.recovery+35)+BigInt(t)*J;return{r:n,s:o,v:a}}function Te(s,e){return s===k||s===Y?s:e===void 0?s-R:s-(e*J+BigInt(35))}function ke(s){return s===k||s===Y}const Ge=function(s,e,t,r,i){const n=de(U(t,32),U(r,32)),o=Te(e,i);if(!ke(o))throw new Error("Invalid signature v value");return he.Signature.fromCompact(n).addRecoveryBit(Number(o)).recoverPublicKey(s).toRawBytes(!1).slice(1)},Be=xe(pe),Me=32,ee=4096,_=32*ee,Ne=2,_e=_*Ne-1,Ue=Me*ee;function Oe(s,e){const t=new Uint8Array(e*_).fill(0);return t.set(s),t[s.byteLength]=128,t}function $e(s){const e=new Uint8Array(Ue);for(let t=0;t<ee;t++){const r=new Uint8Array(32);r.set(s.subarray(t*31,(t+1)*31),0),e.set(r,t*32)}return e}const Ve=s=>{const e=Le(s),t=e.byteLength;if(t===0)throw Error("invalid blob data");if(t>_e)throw Error("blob data is too large");const r=Math.ceil(t/_),i=Oe(e,r),n=[];for(let o=0;o<r;o++){const a=i.subarray(o*_,(o+1)*_),c=$e(a);n.push(c)}return n},He=(s,e)=>{const t=[];for(const r of e)t.push(s.blobToKzgCommitment(r));return t},Je=(s,e,t)=>e.map((i,n)=>s.computeBlobKzgProof(i,t[n])),ue=(s,e)=>{const t=new Uint8Array(32);return t.set([e],0),t.set(Be(s).subarray(1),1),t},Re=s=>{const e=[];for(const t of s)e.push(ue(t,1));return e},Ke=async(s,e)=>{const t=JSON.stringify({method:e.method,params:e.params,jsonrpc:"2.0",id:1}),r=await fetch(s,{headers:{"content-type":"application/json"},method:"POST",body:t});if(!r.ok)throw new Error(`JSONRpcError: ${JSON.stringify({method:e.method,status:r.status,message:await r.text().catch(()=>"Could not parse error message likely because of a network error")},null,2)}`);return(await r.json()).result},je=s=>{if(typeof s=="string")return s;if(typeof s=="object"&&s._getConnection!==void 0)return s._getConnection().url;throw new Error("Must provide valid provider URL or Web3Provider")};var I;(function(s){s[s.EIP155ReplayProtection=155]="EIP155ReplayProtection",s[s.EIP1559FeeMarket=1559]="EIP1559FeeMarket",s[s.EIP2718TypedTransaction=2718]="EIP2718TypedTransaction",s[s.EIP2930AccessLists=2930]="EIP2930AccessLists"})(I||(I={}));function De(s){if(s.length===0)return!0;const e=s[0];return!!Array.isArray(e)}function Xe(s){return!De(s)}var l;(function(s){s[s.Legacy=0]="Legacy",s[s.AccessListEIP2930=1]="AccessListEIP2930",s[s.FeeMarketEIP1559=2]="FeeMarketEIP1559",s[s.BlobEIP4844=3]="BlobEIP4844"})(l||(l={}));function Ze(s){return Number(u(d(s.type)))===l.Legacy}function qe(s){return Number(u(d(s.type)))===l.AccessListEIP2930}function We(s){return Number(u(d(s.type)))===l.FeeMarketEIP1559}function Ye(s){return Number(u(d(s.type)))===l.BlobEIP4844}function Qe(s,e){const t=s.param("vm","maxInitCodeSize");if(t&&BigInt(e)>t)throw new Error(`the initcode size of this transaction is too large: it is ${e} while the max is ${s.param("vm","maxInitCodeSize")}`)}class x{static getAccessListData(e){let t,r;if(Xe(e)){t=e;const i=[];for(let n=0;n<e.length;n++){const o=e[n],a=Z(o.address),c=[];for(let m=0;m<o.storageKeys.length;m++)c.push(Z(o.storageKeys[m]));i.push([a,c])}r=i}else{r=e??[];const i=[];for(let n=0;n<r.length;n++){const o=r[n],a=v(o[0]),c=[];for(let f=0;f<o[1].length;f++)c.push(v(o[1][f]));const m={address:a,storageKeys:c};i.push(m)}t=i}return{AccessListJSON:t,accessList:r}}static verifyAccessList(e){for(let t=0;t<e.length;t++){const r=e[t],i=r[0],n=r[1];if(r[2]!==void 0)throw new Error("Access list item cannot have 3 elements. It can only have an address, and an array of storage slots.");if(i.length!==20)throw new Error("Invalid EIP-2930 transaction: address length should be 20 bytes");for(let o=0;o<n.length;o++)if(n[o].length!==32)throw new Error("Invalid EIP-2930 transaction: storage slot length should be 32 bytes")}}static getAccessListJSON(e){const t=[];for(let r=0;r<e.length;r++){const i=e[r],n={address:v(U(i[0],20)),storageKeys:[]},o=i[1];for(let a=0;a<o.length;a++){const c=o[a];n.storageKeys.push(v(U(c,32)))}t.push(n)}return t}static getDataFeeEIP2930(e,t){const r=t.param("gasPrices","accessListStorageKeyCost"),i=t.param("gasPrices","accessListAddressCost");let n=0;for(let a=0;a<e.length;a++){const m=e[a][1];n+=m.length}return e.length*Number(i)+n*Number(r)}}function O(s){return Z("0x"+s.toString(16).padStart(2,"0"))}class L{constructor(e,t){this.cache={hash:void 0,dataFee:void 0,senderPubKey:void 0},this.activeCapabilities=[],this.DEFAULT_CHAIN=ze.Mainnet;const{nonce:r,gasLimit:i,to:n,value:o,data:a,v:c,r:m,s:f,type:y}=e;this._type=Number(u(d(y))),this.txOptions=t;const b=d(n===""?"0x":n),g=d(c===""?"0x":c),w=d(m===""?"0x":m),M=d(f===""?"0x":f);this.nonce=u(d(r===""?"0x":r)),this.gasLimit=u(d(i===""?"0x":i)),this.to=b.length>0?new E(b):void 0,this.value=u(d(o===""?"0x":o)),this.data=d(a===""?"0x":a),this.v=g.length>0?u(g):void 0,this.r=w.length>0?u(w):void 0,this.s=M.length>0?u(M):void 0,this._validateCannotExceedMaxInteger({value:this.value,r:this.r,s:this.s}),this._validateCannotExceedMaxInteger({gasLimit:this.gasLimit},64),this._validateCannotExceedMaxInteger({nonce:this.nonce},64,!0);const $=this.to===void 0||this.to===null,V=t.allowUnlimitedInitCodeSize??!1,N=t.common??this._getCommon();$&&N.isActivatedEIP(3860)&&V===!1&&Qe(N,this.data.length)}get type(){return this._type}supports(e){return this.activeCapabilities.includes(e)}getValidationErrors(){const e=[];return this.isSigned()&&!this.verifySignature()&&e.push("Invalid Signature"),this.getBaseFee()>this.gasLimit&&e.push(`gasLimit is too low. given ${this.gasLimit}, need at least ${this.getBaseFee()}`),e}isValid(){return this.getValidationErrors().length===0}getBaseFee(){const e=this.common.param("gasPrices","tx");let t=this.getDataFee();if(e&&(t+=e),this.common.gteHardfork("homestead")&&this.toCreationAddress()){const r=this.common.param("gasPrices","txCreation");r&&(t+=r)}return t}getDataFee(){const e=this.common.param("gasPrices","txDataZero"),t=this.common.param("gasPrices","txDataNonZero");let r=k;for(let i=0;i<this.data.length;i++)this.data[i]===0?r+=e:r+=t;if((this.to===void 0||this.to===null)&&this.common.isActivatedEIP(3860)){const i=BigInt(Math.ceil(this.data.length/32)),n=this.common.param("gasPrices","initCodeWordCost")*i;r+=n}return r}toCreationAddress(){return this.to===void 0||this.to.bytes.length===0}isSigned(){const{v:e,r:t,s:r}=this;return!(e===void 0||t===void 0||r===void 0)}verifySignature(){try{const e=this.getSenderPublicKey();return q(e).length!==0}catch{return!1}}getSenderAddress(){return new E(Se(this.getSenderPublicKey()))}sign(e){var m;if(e.length!==32){const f=this._errorMsg("Private key must be 32 bytes in length.");throw new Error(f)}let t=!1;this.type===l.Legacy&&this.common.gteHardfork("spuriousDragon")&&!this.supports(I.EIP155ReplayProtection)&&(this.activeCapabilities.push(I.EIP155ReplayProtection),t=!0);const r=this.getHashedMessageToSign(),i=((m=this.common.customCrypto)==null?void 0:m.ecsign)??Ce,{v:n,r:o,s:a}=i(r,e),c=this.addSignature(n,o,a,!0);if(t){const f=this.activeCapabilities.indexOf(I.EIP155ReplayProtection);f>-1&&this.activeCapabilities.splice(f,1)}return c}toJSON(){return{type:P(BigInt(this.type)),nonce:P(this.nonce),gasLimit:P(this.gasLimit),to:this.to!==void 0?this.to.toString():void 0,value:P(this.value),data:v(this.data),v:this.v!==void 0?P(this.v):void 0,r:this.r!==void 0?P(this.r):void 0,s:this.s!==void 0?P(this.s):void 0}}_getCommon(e,t){if(t!==void 0){const r=u(d(t));if(e){if(e.chainId()!==r){const i=this._errorMsg(`The chain ID does not match the chain ID of Common. Got: ${r}, expected: ${e.chainId}`);throw new Error(i)}return e.copy()}else return H.isSupportedChainId(r)?new H({chain:r}):H.custom({name:"custom-chain",networkId:r,chainId:r},{baseChain:this.DEFAULT_CHAIN})}else return(e==null?void 0:e.copy())??new H({chain:this.DEFAULT_CHAIN})}_validateCannotExceedMaxInteger(e,t=256,r=!1){for(const[i,n]of Object.entries(e))switch(t){case 64:if(r){if(n!==void 0&&n>=ie){const o=this._errorMsg(`${i} cannot equal or exceed MAX_UINT64 (2^64-1), given ${n}`);throw new Error(o)}}else if(n!==void 0&&n>ie){const o=this._errorMsg(`${i} cannot exceed MAX_UINT64 (2^64-1), given ${n}`);throw new Error(o)}break;case 256:if(r){if(n!==void 0&&n>=B){const o=this._errorMsg(`${i} cannot equal or exceed MAX_INTEGER (2^256-1), given ${n}`);throw new Error(o)}}else if(n!==void 0&&n>B){const o=this._errorMsg(`${i} cannot exceed MAX_INTEGER (2^256-1), given ${n}`);throw new Error(o)}break;default:{const o=this._errorMsg("unimplemented bits value");throw new Error(o)}}}static _validateNotArray(e){const t=["nonce","gasPrice","gasLimit","to","value","data","v","r","s","type","baseFee","maxFeePerGas","chainId"];for(const[r,i]of Object.entries(e))if(t.includes(r)&&Array.isArray(i))throw new Error(`${r} cannot be an array`)}_getSharedErrorPostfix(){let e="";try{e=this.isSigned()?v(this.hash()):"not available (unsigned)"}catch{e="error"}let t="";try{t=this.isSigned().toString()}catch{e="error"}let r="";try{r=this.common.hardfork()}catch{r="error"}let i=`tx type=${this.type} hash=${e} nonce=${this.nonce} value=${this.value} `;return i+=`signed=${t} hf=${r}`,i}}function me(s,e){const t=s.maxPriorityFeePerGas,r=s.maxFeePerGas-e,n=(t<r?t:r)+e;return s.gasLimit*n+s.value}function ge(s,e){if(e===void 0||e>s.maxFeePerGas)throw new Error("Tx cannot pay baseFee");const t=s.maxFeePerGas-e;return s.maxPriorityFeePerGas<t?s.maxPriorityFeePerGas:t}function F(s,e){return`${e} (${s.errorStr()})`}function fe(s,e){if(s.cache.dataFee&&s.cache.dataFee.hardfork===s.common.hardfork())return s.cache.dataFee.value;const t=L.prototype.getDataFee.bind(s)()+(e??0n);return Object.isFrozen(s)&&(s.cache.dataFee={value:t,hardfork:s.common.hardfork()}),t}function j(s){if(!s.isSigned()){const t=F(s,"Cannot call hash method if transaction is not signed");throw new Error(t)}const e=s.common.customCrypto.keccak256??Q;return Object.isFrozen(s)?(s.cache.hash||(s.cache.hash=e(s.serialize())),s.cache.hash):e(s.serialize())}function D(s){const{s:e}=s;if(s.common.gteHardfork("homestead")&&e!==void 0&&e>Ae){const t=F(s,"Invalid Signature: s-values greater than secp256k1n/2 are considered invalid");throw new Error(t)}}function X(s){if(s.cache.senderPubKey!==void 0)return s.cache.senderPubKey;const e=s.getMessageToVerifySignature(),{v:t,r,s:i}=s;D(s);try{const o=(s.common.customCrypto.ecrecover??Ge)(e,t,h(r),h(i),s.supports(I.EIP155ReplayProtection)?s.common.chainId():void 0);return Object.isFrozen(s)&&(s.cache.senderPubKey=o),o}catch{const o=F(s,"Invalid Signature");throw new Error(o)}}function le(s,e){if(e!==void 0&&e>s)throw new Error("Tx cannot pay baseFee");return e===void 0?s:s-e}function te(s){return(s.common.customCrypto.keccak256??Q)(s.getMessageToSign())}function T(s,e){return de(O(s.type),A.encode(e??s.raw()))}function se(s){const{v:e}=s;if(e!==void 0&&e!==k&&e!==Y){const t=F(s,"The y-parity of the transaction should either be 0 or 1");throw new Error(t)}}function re(s){return fe(s,BigInt(x.getDataFeeEIP2930(s.accessList,s.common)))}class z extends L{constructor(e,t={}){super({...e,type:l.FeeMarketEIP1559},t);const{chainId:r,accessList:i,maxFeePerGas:n,maxPriorityFeePerGas:o}=e;if(this.common=this._getCommon(t.common,r),this.chainId=this.common.chainId(),this.common.isActivatedEIP(1559)===!1)throw new Error("EIP-1559 not enabled on Common");this.activeCapabilities=this.activeCapabilities.concat([1559,2718,2930]);const a=x.getAccessListData(i??[]);if(this.accessList=a.accessList,this.AccessListJSON=a.AccessListJSON,x.verifyAccessList(this.accessList),this.maxFeePerGas=u(d(n===""?"0x":n)),this.maxPriorityFeePerGas=u(d(o===""?"0x":o)),this._validateCannotExceedMaxInteger({maxFeePerGas:this.maxFeePerGas,maxPriorityFeePerGas:this.maxPriorityFeePerGas}),L._validateNotArray(e),this.gasLimit*this.maxFeePerGas>B){const m=this._errorMsg("gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)");throw new Error(m)}if(this.maxFeePerGas<this.maxPriorityFeePerGas){const m=this._errorMsg("maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)");throw new Error(m)}se(this),D(this),((t==null?void 0:t.freeze)??!0)&&Object.freeze(this)}static fromTxData(e,t={}){return new z(e,t)}static fromSerializedTx(e,t={}){if(G(e.subarray(0,1),O(l.FeeMarketEIP1559))===!1)throw new Error(`Invalid serialized tx input: not an EIP-1559 transaction (wrong tx type, expected: ${l.FeeMarketEIP1559}, received: ${v(e.subarray(0,1))}`);const r=A.decode(e.subarray(1));if(!Array.isArray(r))throw new Error("Invalid serialized tx input: must be array");return z.fromValuesArray(r,t)}static fromValuesArray(e,t={}){if(e.length!==9&&e.length!==12)throw new Error("Invalid EIP-1559 transaction. Only expecting 9 values (for unsigned tx) or 12 values (for signed tx).");const[r,i,n,o,a,c,m,f,y,b,g,w]=e;return this._validateNotArray({chainId:r,v:b}),K({nonce:i,maxPriorityFeePerGas:n,maxFeePerGas:o,gasLimit:a,value:m,v:b,r:g,s:w}),new z({chainId:u(r),nonce:i,maxPriorityFeePerGas:n,maxFeePerGas:o,gasLimit:a,to:c,value:m,data:f,accessList:y??[],v:b!==void 0?u(b):void 0,r:g,s:w},t)}getDataFee(){return re(this)}getEffectivePriorityFee(e){return ge(this,e)}getUpfrontCost(e=k){return me(this,e)}raw(){return[h(this.chainId),h(this.nonce),h(this.maxPriorityFeePerGas),h(this.maxFeePerGas),h(this.gasLimit),this.to!==void 0?this.to.bytes:new Uint8Array(0),h(this.value),this.data,this.accessList,this.v!==void 0?h(this.v):new Uint8Array(0),this.r!==void 0?h(this.r):new Uint8Array(0),this.s!==void 0?h(this.s):new Uint8Array(0)]}serialize(){return T(this)}getMessageToSign(){return T(this,this.raw().slice(0,9))}getHashedMessageToSign(){return te(this)}hash(){return j(this)}getMessageToVerifySignature(){return this.getHashedMessageToSign()}getSenderPublicKey(){return X(this)}addSignature(e,t,r,i=!1){t=d(t),r=d(r);const n={...this.txOptions,common:this.common};return z.fromTxData({chainId:this.chainId,nonce:this.nonce,maxPriorityFeePerGas:this.maxPriorityFeePerGas,maxFeePerGas:this.maxFeePerGas,gasLimit:this.gasLimit,to:this.to,value:this.value,data:this.data,accessList:this.accessList,v:i?e-R:e,r:u(t),s:u(r)},n)}toJSON(){const e=x.getAccessListJSON(this.accessList);return{...super.toJSON(),chainId:P(this.chainId),maxPriorityFeePerGas:P(this.maxPriorityFeePerGas),maxFeePerGas:P(this.maxFeePerGas),accessList:e}}errorStr(){let e=this._getSharedErrorPostfix();return e+=` maxFeePerGas=${this.maxFeePerGas} maxPriorityFeePerGas=${this.maxPriorityFeePerGas}`,e}_errorMsg(e){return F(this,e)}}class C extends L{constructor(e,t={}){super({...e,type:l.AccessListEIP2930},t);const{chainId:r,accessList:i,gasPrice:n}=e;if(this.common=this._getCommon(t.common,r),this.chainId=this.common.chainId(),!this.common.isActivatedEIP(2930))throw new Error("EIP-2930 not enabled on Common");this.activeCapabilities=this.activeCapabilities.concat([2718,2930]);const o=x.getAccessListData(i??[]);if(this.accessList=o.accessList,this.AccessListJSON=o.AccessListJSON,x.verifyAccessList(this.accessList),this.gasPrice=u(d(n===""?"0x":n)),this._validateCannotExceedMaxInteger({gasPrice:this.gasPrice}),L._validateNotArray(e),this.gasPrice*this.gasLimit>B){const c=this._errorMsg("gasLimit * gasPrice cannot exceed MAX_INTEGER");throw new Error(c)}se(this),D(this),((t==null?void 0:t.freeze)??!0)&&Object.freeze(this)}static fromTxData(e,t={}){return new C(e,t)}static fromSerializedTx(e,t={}){if(G(e.subarray(0,1),O(l.AccessListEIP2930))===!1)throw new Error(`Invalid serialized tx input: not an EIP-2930 transaction (wrong tx type, expected: ${l.AccessListEIP2930}, received: ${v(e.subarray(0,1))}`);const r=A.decode(Uint8Array.from(e.subarray(1)));if(!Array.isArray(r))throw new Error("Invalid serialized tx input: must be array");return C.fromValuesArray(r,t)}static fromValuesArray(e,t={}){if(e.length!==8&&e.length!==11)throw new Error("Invalid EIP-2930 transaction. Only expecting 8 values (for unsigned tx) or 11 values (for signed tx).");const[r,i,n,o,a,c,m,f,y,b,g]=e;this._validateNotArray({chainId:r,v:y}),K({nonce:i,gasPrice:n,gasLimit:o,value:c,v:y,r:b,s:g});const w=[];return new C({chainId:u(r),nonce:i,gasPrice:n,gasLimit:o,to:a,value:c,data:m,accessList:f??w,v:y!==void 0?u(y):void 0,r:b,s:g},t)}getEffectivePriorityFee(e){return le(this.gasPrice,e)}getDataFee(){return re(this)}getUpfrontCost(){return this.gasLimit*this.gasPrice+this.value}raw(){return[h(this.chainId),h(this.nonce),h(this.gasPrice),h(this.gasLimit),this.to!==void 0?this.to.bytes:new Uint8Array(0),h(this.value),this.data,this.accessList,this.v!==void 0?h(this.v):new Uint8Array(0),this.r!==void 0?h(this.r):new Uint8Array(0),this.s!==void 0?h(this.s):new Uint8Array(0)]}serialize(){return T(this)}getMessageToSign(){return T(this,this.raw().slice(0,8))}getHashedMessageToSign(){return te(this)}hash(){return j(this)}getMessageToVerifySignature(){return this.getHashedMessageToSign()}getSenderPublicKey(){return X(this)}addSignature(e,t,r,i=!1){t=d(t),r=d(r);const n={...this.txOptions,common:this.common};return C.fromTxData({chainId:this.chainId,nonce:this.nonce,gasPrice:this.gasPrice,gasLimit:this.gasLimit,to:this.to,value:this.value,data:this.data,accessList:this.accessList,v:i?e-R:e,r:u(t),s:u(r)},n)}toJSON(){const e=x.getAccessListJSON(this.accessList);return{...super.toJSON(),chainId:P(this.chainId),gasPrice:P(this.gasPrice),accessList:e}}errorStr(){var t;let e=this._getSharedErrorPostfix();return e+=` gasPrice=${this.gasPrice} accessListCount=${((t=this.accessList)==null?void 0:t.length)??0}`,e}_errorMsg(e){return F(this,e)}}const ae=6,et=(s,e,t,r,i,n)=>{if(!(s.length===e.length&&e.length===t.length))throw new Error("Number of blobVersionedHashes, blobs, and commitments not all equal");if(s.length===0)throw new Error("Invalid transaction with empty blobs");let o;try{o=n.verifyBlobKzgProofBatch(e,t,r)}catch(a){throw new Error(`KZG verification of blobs fail with error=${a}`)}if(!o)throw new Error("KZG proof cannot be verified from blobs/commitments");for(let a=0;a<s.length;a++){const c=ue(t[a],i);if(!G(c,s[a]))throw new Error(`commitment for blob at index ${a} does not match versionedHash`)}};class p extends L{constructor(e,t={}){var f,y,b;super({...e,type:l.BlobEIP4844},t);const{chainId:r,accessList:i,maxFeePerGas:n,maxPriorityFeePerGas:o,maxFeePerBlobGas:a}=e;if(this.common=this._getCommon(t.common,r),this.chainId=this.common.chainId(),this.common.isActivatedEIP(1559)===!1)throw new Error("EIP-1559 not enabled on Common");if(this.common.isActivatedEIP(4844)===!1)throw new Error("EIP-4844 not enabled on Common");this.activeCapabilities=this.activeCapabilities.concat([1559,2718,2930]);const c=x.getAccessListData(i??[]);if(this.accessList=c.accessList,this.AccessListJSON=c.AccessListJSON,x.verifyAccessList(this.accessList),this.maxFeePerGas=u(d(n===""?"0x":n)),this.maxPriorityFeePerGas=u(d(o===""?"0x":o)),this._validateCannotExceedMaxInteger({maxFeePerGas:this.maxFeePerGas,maxPriorityFeePerGas:this.maxPriorityFeePerGas}),L._validateNotArray(e),this.gasLimit*this.maxFeePerGas>B){const g=this._errorMsg("gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)");throw new Error(g)}if(this.maxFeePerGas<this.maxPriorityFeePerGas){const g=this._errorMsg("maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)");throw new Error(g)}this.maxFeePerBlobGas=u(d((a??"")===""?"0x":a)),this.blobVersionedHashes=(e.blobVersionedHashes??[]).map(g=>d(g)),se(this),D(this);for(const g of this.blobVersionedHashes){if(g.length!==32){const w=this._errorMsg("versioned hash is invalid length");throw new Error(w)}if(BigInt(g[0])!==this.common.param("sharding","blobCommitmentVersionKzg")){const w=this._errorMsg("versioned hash does not start with KZG commitment version");throw new Error(w)}}if(this.blobVersionedHashes.length>ae){const g=this._errorMsg(`tx can contain at most ${ae} blobs`);throw new Error(g)}else if(this.blobVersionedHashes.length===0){const g=this._errorMsg("tx should contain at least one blob");throw new Error(g)}if(this.to===void 0){const g=this._errorMsg('tx should have a "to" field and cannot be used to create contracts');throw new Error(g)}this.blobs=(f=e.blobs)==null?void 0:f.map(g=>d(g)),this.kzgCommitments=(y=e.kzgCommitments)==null?void 0:y.map(g=>d(g)),this.kzgProofs=(b=e.kzgProofs)==null?void 0:b.map(g=>d(g)),((t==null?void 0:t.freeze)??!0)&&Object.freeze(this)}static fromTxData(e,t){var i,n;if(((n=(i=t==null?void 0:t.common)==null?void 0:i.customCrypto)==null?void 0:n.kzg)===void 0)throw new Error("A common object with customCrypto.kzg initialized required to instantiate a 4844 blob tx");const r=t.common.customCrypto.kzg;if(e.blobsData!==void 0){if(e.blobs!==void 0)throw new Error("cannot have both raw blobs data and encoded blobs in constructor");if(e.kzgCommitments!==void 0)throw new Error("cannot have both raw blobs data and KZG commitments in constructor");if(e.blobVersionedHashes!==void 0)throw new Error("cannot have both raw blobs data and versioned hashes in constructor");if(e.kzgProofs!==void 0)throw new Error("cannot have both raw blobs data and KZG proofs in constructor");e.blobs=Ve(e.blobsData.reduce((o,a)=>o+a)),e.kzgCommitments=He(r,e.blobs),e.blobVersionedHashes=Re(e.kzgCommitments),e.kzgProofs=Je(r,e.blobs,e.kzgCommitments)}return new p(e,t)}getEffectivePriorityFee(e){return ge(this,e)}static minimalFromNetworkWrapper(e,t){var i,n;if(((n=(i=t==null?void 0:t.common)==null?void 0:i.customCrypto)==null?void 0:n.kzg)===void 0)throw new Error("A common object with customCrypto.kzg initialized required to instantiate a 4844 blob tx");return p.fromTxData({...e,blobs:void 0,kzgCommitments:void 0,kzgProofs:void 0},t)}static fromSerializedTx(e,t={}){var i,n;if(((n=(i=t.common)==null?void 0:i.customCrypto)==null?void 0:n.kzg)===void 0)throw new Error("A common object with customCrypto.kzg initialized required to instantiate a 4844 blob tx");if(G(e.subarray(0,1),O(l.BlobEIP4844))===!1)throw new Error(`Invalid serialized tx input: not an EIP-4844 transaction (wrong tx type, expected: ${l.BlobEIP4844}, received: ${v(e.subarray(0,1))}`);const r=A.decode(e.subarray(1));if(!Array.isArray(r))throw new Error("Invalid serialized tx input: must be array");return p.fromValuesArray(r,t)}static fromValuesArray(e,t={}){var V,N;if(((N=(V=t.common)==null?void 0:V.customCrypto)==null?void 0:N.kzg)===void 0)throw new Error("A common object with customCrypto.kzg initialized required to instantiate a 4844 blob tx");if(e.length!==11&&e.length!==14)throw new Error("Invalid EIP-4844 transaction. Only expecting 11 values (for unsigned tx) or 14 values (for signed tx).");const[r,i,n,o,a,c,m,f,y,b,g,w,M,$]=e;return this._validateNotArray({chainId:r,v:w}),K({nonce:i,maxPriorityFeePerGas:n,maxFeePerGas:o,gasLimit:a,value:m,maxFeePerBlobGas:b,v:w,r:M,s:$}),new p({chainId:u(r),nonce:i,maxPriorityFeePerGas:n,maxFeePerGas:o,gasLimit:a,to:c,value:m,data:f,accessList:y??[],maxFeePerBlobGas:b,blobVersionedHashes:g,v:w!==void 0?u(w):void 0,r:M,s:$},t)}static fromSerializedBlobTxNetworkWrapper(e,t){var y,b;if(!t||!t.common)throw new Error("common instance required to validate versioned hashes");if(((b=(y=t.common)==null?void 0:y.customCrypto)==null?void 0:b.kzg)===void 0)throw new Error("A common object with customCrypto.kzg initialized required to instantiate a 4844 blob tx");if(G(e.subarray(0,1),O(l.BlobEIP4844))===!1)throw new Error(`Invalid serialized tx input: not an EIP-4844 transaction (wrong tx type, expected: ${l.BlobEIP4844}, received: ${v(e.subarray(0,1))}`);const r=A.decode(e.subarray(1));if(r.length!==4)throw Error("Expected 4 values in the deserialized network transaction");const[i,n,o,a]=r,c=p.fromValuesArray(i,{...t,freeze:!1});if(c.to===void 0)throw Error("BlobEIP4844Transaction can not be send without a valid `to`");const m=Number(t.common.param("sharding","blobCommitmentVersionKzg"));return et(c.blobVersionedHashes,n,o,a,m,t.common.customCrypto.kzg),c.blobs=n,c.kzgCommitments=o,c.kzgProofs=a,((t==null?void 0:t.freeze)??!0)&&Object.freeze(c),c}getDataFee(){return re(this)}getUpfrontCost(e=k){return me(this,e)}raw(){return[h(this.chainId),h(this.nonce),h(this.maxPriorityFeePerGas),h(this.maxFeePerGas),h(this.gasLimit),this.to!==void 0?this.to.bytes:new Uint8Array(0),h(this.value),this.data,this.accessList,h(this.maxFeePerBlobGas),this.blobVersionedHashes,this.v!==void 0?h(this.v):new Uint8Array(0),this.r!==void 0?h(this.r):new Uint8Array(0),this.s!==void 0?h(this.s):new Uint8Array(0)]}serialize(){return T(this)}serializeNetworkWrapper(){if(this.blobs===void 0||this.kzgCommitments===void 0||this.kzgProofs===void 0)throw new Error("cannot serialize network wrapper without blobs, KZG commitments and KZG proofs provided");return T(this,[this.raw(),this.blobs,this.kzgCommitments,this.kzgProofs])}getMessageToSign(){return T(this,this.raw().slice(0,11))}getHashedMessageToSign(){return te(this)}hash(){return j(this)}getMessageToVerifySignature(){return this.getHashedMessageToSign()}getSenderPublicKey(){return X(this)}toJSON(){const e=x.getAccessListJSON(this.accessList);return{...super.toJSON(),chainId:P(this.chainId),maxPriorityFeePerGas:P(this.maxPriorityFeePerGas),maxFeePerGas:P(this.maxFeePerGas),accessList:e,maxFeePerBlobGas:P(this.maxFeePerBlobGas),blobVersionedHashes:this.blobVersionedHashes.map(r=>v(r))}}addSignature(e,t,r,i=!1){t=d(t),r=d(r);const n={...this.txOptions,common:this.common};return p.fromTxData({chainId:this.chainId,nonce:this.nonce,maxPriorityFeePerGas:this.maxPriorityFeePerGas,maxFeePerGas:this.maxFeePerGas,gasLimit:this.gasLimit,to:this.to,value:this.value,data:this.data,accessList:this.accessList,v:i?e-R:e,r:u(t),s:u(r),maxFeePerBlobGas:this.maxFeePerBlobGas,blobVersionedHashes:this.blobVersionedHashes,blobs:this.blobs,kzgCommitments:this.kzgCommitments,kzgProofs:this.kzgProofs},n)}errorStr(){let e=this._getSharedErrorPostfix();return e+=` maxFeePerGas=${this.maxFeePerGas} maxPriorityFeePerGas=${this.maxPriorityFeePerGas}`,e}_errorMsg(e){return F(this,e)}numBlobs(){return this.blobVersionedHashes.length}}function ce(s,e){const t=Number(s),r=Number(e)*2;return t===r+35||t===r+36}class S extends L{constructor(e,t={}){if(super({...e,type:l.Legacy},t),this.common=this._validateTxV(this.v,t.common),this.keccakFunction=this.common.customCrypto.keccak256??Q,this.gasPrice=u(d(e.gasPrice===""?"0x":e.gasPrice)),this.gasPrice*this.gasLimit>B){const i=this._errorMsg("gas limit * gasPrice cannot exceed MAX_INTEGER (2^256-1)");throw new Error(i)}this._validateCannotExceedMaxInteger({gasPrice:this.gasPrice}),L._validateNotArray(e),this.common.gteHardfork("spuriousDragon")&&(this.isSigned()?ce(this.v,this.common.chainId())&&this.activeCapabilities.push(I.EIP155ReplayProtection):this.activeCapabilities.push(I.EIP155ReplayProtection)),((t==null?void 0:t.freeze)??!0)&&Object.freeze(this)}static fromTxData(e,t={}){return new S(e,t)}static fromSerializedTx(e,t={}){const r=A.decode(e);if(!Array.isArray(r))throw new Error("Invalid serialized tx input. Must be array");return this.fromValuesArray(r,t)}static fromValuesArray(e,t={}){if(e.length!==6&&e.length!==9)throw new Error("Invalid transaction. Only expecting 6 values (for unsigned tx) or 9 values (for signed tx).");const[r,i,n,o,a,c,m,f,y]=e;return K({nonce:r,gasPrice:i,gasLimit:n,value:a,v:m,r:f,s:y}),new S({nonce:r,gasPrice:i,gasLimit:n,to:o,value:a,data:c,v:m,r:f,s:y},t)}getEffectivePriorityFee(e){return le(this.gasPrice,e)}raw(){return[h(this.nonce),h(this.gasPrice),h(this.gasLimit),this.to!==void 0?this.to.bytes:new Uint8Array(0),h(this.value),this.data,this.v!==void 0?h(this.v):new Uint8Array(0),this.r!==void 0?h(this.r):new Uint8Array(0),this.s!==void 0?h(this.s):new Uint8Array(0)]}serialize(){return A.encode(this.raw())}getMessageToSign(){const e=[h(this.nonce),h(this.gasPrice),h(this.gasLimit),this.to!==void 0?this.to.bytes:new Uint8Array(0),h(this.value),this.data];return this.supports(I.EIP155ReplayProtection)&&(e.push(h(this.common.chainId())),e.push(q(d(0))),e.push(q(d(0)))),e}getHashedMessageToSign(){const e=this.getMessageToSign();return this.keccakFunction(A.encode(e))}getDataFee(){return fe(this)}getUpfrontCost(){return this.gasLimit*this.gasPrice+this.value}hash(){return j(this)}getMessageToVerifySignature(){if(!this.isSigned()){const e=this._errorMsg("This transaction is not signed");throw new Error(e)}return this.getHashedMessageToSign()}getSenderPublicKey(){return X(this)}addSignature(e,t,r,i=!1){t=d(t),r=d(r),i&&this.supports(I.EIP155ReplayProtection)&&(e+=this.common.chainId()*J+Fe);const n={...this.txOptions,common:this.common};return S.fromTxData({nonce:this.nonce,gasPrice:this.gasPrice,gasLimit:this.gasLimit,to:this.to,value:this.value,data:this.data,v:e,r:u(t),s:u(r)},n)}toJSON(){return{...super.toJSON(),gasPrice:P(this.gasPrice)}}_validateTxV(e,t){let r;const i=e!==void 0?Number(e):void 0;if(i!==void 0&&i<37&&i!==27&&i!==28)throw new Error(`Legacy txs need either v = 27/28 or v >= 37 (EIP-155 replay protection), got v = ${i}`);if(i!==void 0&&i!==0&&(!t||t.gteHardfork("spuriousDragon"))&&i!==27&&i!==28)if(t){if(!ce(BigInt(i),t.chainId()))throw new Error(`Incompatible EIP155-based V ${i} and chain id ${t.chainId()}. See the Common parameter of the Transaction constructor to set the chain id.`)}else{let n;(i-35)%2===0?n=35:n=36,r=BigInt(i-n)/J}return this._getCommon(t,r)}errorStr(){let e=this._getSharedErrorPostfix();return e+=` gasPrice=${this.gasPrice}`,e}_errorMsg(e){return F(this,e)}}const tt=s=>{const e=Object.assign({},s);return e.gasLimit=ne(e.gasLimit??e.gas,oe.BigInt),e.data=e.data===void 0?e.input:e.data,e.gasPrice=e.gasPrice!==void 0?BigInt(e.gasPrice):void 0,e.value=e.value!==void 0?BigInt(e.value):void 0,e.to=e.to!==null&&e.to!==void 0?U(d(e.to),20):null,e.v=e.v==="0x0"?"0x":e.v,e.r=e.r==="0x0"?"0x":e.r,e.s=e.s==="0x0"?"0x":e.s,(e.v!=="0x"||e.r!=="0x"||e.s!=="0x")&&(e.v=ne(e.v,oe.BigInt)),e};class W{constructor(){}static fromTxData(e,t={}){if(!("type"in e)||e.type===void 0)return S.fromTxData(e,t);if(Ze(e))return S.fromTxData(e,t);if(qe(e))return C.fromTxData(e,t);if(We(e))return z.fromTxData(e,t);if(Ye(e))return p.fromTxData(e,t);throw new Error(`Tx instantiation with type ${e==null?void 0:e.type} not supported`)}static fromSerializedData(e,t={}){if(e[0]<=127)switch(e[0]){case l.AccessListEIP2930:return C.fromSerializedTx(e,t);case l.FeeMarketEIP1559:return z.fromSerializedTx(e,t);case l.BlobEIP4844:return p.fromSerializedTx(e,t);default:throw new Error(`TypedTransaction with ID ${e[0]} unknown`)}else return S.fromSerializedTx(e,t)}static fromBlockBodyData(e,t={}){if(e instanceof Uint8Array)return this.fromSerializedData(e,t);if(Array.isArray(e))return S.fromValuesArray(e,t);throw new Error("Cannot decode transaction: unknown type input")}static async fromJsonRpcProvider(e,t,r){const i=je(e),n=await Ke(i,{method:"eth_getTransactionByHash",params:[t]});if(n===null)throw new Error("No data returned from provider");return W.fromRPC(n,r)}static async fromRPC(e,t={}){return W.fromTxData(tt(e),t)}}export{C as AccessListEIP2930Transaction,p as BlobEIP4844Transaction,I as Capability,z as FeeMarketEIP1559Transaction,S as LegacyTransaction,W as TransactionFactory,l as TransactionType,Xe as isAccessList,De as isAccessListBytes,qe as isAccessListEIP2930TxData,Ye as isBlobEIP4844TxData,We as isFeeMarketEIP1559TxData,Ze as isLegacyTxData};
